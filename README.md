Ниже представлен развернутый теоретический материал, который может помочь при подготовке к экзамену по дисциплине «Программирование на языке Java» (зима 2024–2025). Для некоторых вопросов приведены короткие примеры кода (отрывки), иллюстрирующие основные концепции.

---

## 1. Введение в Java. Основные характеристики языка, сферы применения, история создания. Экосистема языка JAVA. JDK, JRE, JVM

**Характеристики Java:**
1. **Объектно-ориентированный** язык: всё строится вокруг классов и объектов.  
2. **Платформонезависимый**: благодаря байт-коду Java-программа может выполняться на любой платформе, где установлена JVM.  
3. **Безопасность**: механизм управления памятью (Garbage Collector) и структура байт-кода обеспечивают высокую безопасность.  
4. **Многопоточность**: встроенная поддержка потоков.  
5. **Надёжность и строгая типизация**: минимизация ошибок на этапе компиляции и исполнении.  

**Сферы применения:**  
- Серверные и веб-приложения (Spring, Jakarta EE).  
- Мобильные приложения (Android).  
- Enterprise-разработка (банковский сектор, корпоративные системы).  
- Большие данные и аналитика (Hadoop экосистема).  

**История создания:**  
- Язык был разработан в начале 1990-х годов в компании Sun Microsystems (Джеймс Гослинг).  
- Первоначально назывался Oak, позже переименован в Java (1995 г.).  
- В 2010 году Sun Microsystems была поглощена Oracle, которая продолжила развивать Java.

**Экосистема Java:**  
- **JDK (Java Development Kit)** – включает компилятор (javac), инструменты для отладки, профилирования, JRE и др.  
- **JRE (Java Runtime Environment)** – позволяет запускать Java-приложения. Содержит JVM и базовые библиотеки.  
- **JVM (Java Virtual Machine)** – виртуальная машина, которая исполняет байт-код.  

Пример (компиляция и запуск простого приложения):

```java
// HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}
```

```bash
# Компиляция:
javac HelloWorld.java
# Запуск:
java HelloWorld
```

---

## 2. Основные платформы Java. Java SE, Java EE, Java ME, их особенности и области применения

- **Java SE (Standard Edition)**: базовые библиотеки и инструменты. Подходит для настольных приложений, небольших утилит, учебных примеров.  
- **Java EE (Enterprise Edition), ныне Jakarta EE**: надстройка над Java SE, включает спецификации для веб-сервисов, сервлетов, EJB, JMS и прочего. Используется в корпоративных системах.  
- **Java ME (Micro Edition)**: облегчённая платформа для мобильных и встраиваемых устройств (применяется реже, с уходом устройств под управлением Java ME уступила место Android).

---

## 3. Виртуальные машины и их роль в JAVA. Архитектура JVM. Основные компоненты: Class Loader, Execution Engine, Garbage Collector

**Роль виртуальной машины:**  
- Выполняет байт-код независимо от платформы, обеспечивает безопасность и оптимизацию кода.  

**Архитектура JVM:**
1. **Class Loader**: загружает классы (из файлов .class, сетевых ресурсов и т.д.) в память JVM.  
2. **Execution Engine**: интерпретирует байт-код или использует JIT-компилятор для ускорения.  
3. **Garbage Collector**: автоматическое управление памятью, освобождает объекты, на которые нет ссылок.

---

## 4. Компиляция Java-программ. Различия между JIT (Just-in-Time) и AOT (Ahead-of-Time) компиляцией. Преимущества и недостатки

- **JIT (Just-in-Time)**: во время выполнения программа или её часто используемые части компилируются в машинный код.  
  - *Преимущества:* адаптивная оптимизация, высокая производительность в долгосрочной перспективе.  
  - *Недостатки:* первое выполнение может быть медленнее из-за компиляции «на лету».  

- **AOT (Ahead-of-Time)**: компиляция в машинный код происходит заранее.  
  - *Преимущества:* быстрое время запуска, отсутствие задержек на JIT.  
  - *Недостатки:* меньше возможностей динамической оптимизации.

---

## 5. Модель памяти в Java. Основные области памяти JVM: куча (Heap) и стек (Stack), их назначение и различия. Как распределяются объекты и примитивные данные в этих областях? Что такое Young Generation, Old Generation и Metaspace? Как работа сборщика мусора влияет на управление памятью?

- **Heap (куча)**: хранит все объекты и динамические структуры данных. Управляется сборщиком мусора.  
- **Stack (стек)**: хранит примитивные переменные и ссылки на объекты в heap, а также контекст выполнения методов (фреймы вызовов).

**Поколения кучи:**
1. **Young Generation**: объекты, созданные недавно; сборка производится чаще (Minor GC).  
2. **Old Generation**: объекты, «дожившие» до нескольких циклов GC.  
3. **Metaspace**: хранит метаданные о классах (в современных JVM вместо PermGen).

**Работа GC:**  
- «Чистит» память, удаляя объекты, на которые нет активных ссылок.  
- Влияет на производительность из-за пауз, но упрощает жизнь программисту, освобождая от ручного управления памятью.

---

## 6. Основные парадигмы программирования в Java. Объектно-ориентированное, функциональное, многопоточное программирование

- **ООП (Объектно-ориентированное)**: классы, объекты, наследование, инкапсуляция, полиморфизм.  
- **Функциональное** (начиная с Java 8): лямбда-выражения, функциональные интерфейсы (Predicate, Function), Stream API.  
- **Многопоточность**: стандартная библиотека (java.lang.Thread, Executors) + возможности высокоуровневой синхронизации (synchronized, java.util.concurrent).

---

## 7. Виртуальные машины и их роль в JAVA. Особенности стандартной HotSpot JVM. GraalVM и другие сторонние виртуальные машины для Java. Основные преимущества и возможности сторонних виртуальных машин

- **HotSpot JVM**: стандартная реализация от Oracle (OpenJDK), с развитым JIT-компилятором и оптимизациями.  
- **GraalVM**: универсальная виртуальная машина от Oracle, поддерживает Java, Kotlin, Scala, а также JavaScript, Python и др. Позволяет делать AOT-компиляцию и «native image».  
- **Другие JVM**: Azul Zing, OpenJ9 (IBM) – специализируются на низких паузах GC, повышенной масштабируемости.  

---

## 8. Компиляция и запуск проекта на Java. Обеспечение переносимости кода на различные платформы. Понятие промежуточного байт-кода и его роль в переносимости программ. Чем отличаются методы компиляции JIT (Just-In-Time) и AOT (Ahead-of-Time), и как они влияют на производительность и переносимость?

- **Промежуточный байт-код**: результат компиляции (.class-файлы) – универсальный формат, исполняемый на JVM, что обеспечивает кроссплатформенность.  
- **JIT и AOT** (описано в вопросе 4): оба метода не влияют на переносимость, т.к. байт-код остаётся одним и тем же. Но JIT/AOT влияют на *время* и *оптимизацию* выполнения.

---

## 9. Современный инструментарий разработчика Java. Популярные IDE и их возможностей для написания, отладки и сборки кода. Основные системы сборки и их роль в управлении проектами на JAVA. Контроль версий с использованием Git и интеграция с платформами хостинга ИТ-проектов. Использование Docker и Kubernetes для контейнеризации и оркестрации приложений. Инструменты CI/CD для автоматизации сборки, тестирования и деплоя JAVA-приложений

- **IDE**: IntelliJ IDEA, Eclipse, NetBeans – поддержка рефакторинга, автодополнения, отладки.  
- **Системы сборки**: 
  - **Maven**: декларативный подход (pom.xml), управление зависимостями.  
  - **Gradle**: скриптовой подход (build.gradle), гибкая конфигурация.  
- **Git**: система контроля версий, GitHub/GitLab/Bitbucket для хостинга.  
- **Docker и Kubernetes**: контейнеризация (Dockerfile), оркестрация (Deployment, Service, Pod в Kubernetes).  
- **CI/CD**: Jenkins, GitLab CI, GitHub Actions. Автоматическая сборка, тесты, деплой.

---

## 10. Современные фреймворки для разработки на Java. Особенности Spring Framework. Основные возможности Hibernate. Основные причины использования данных фреймворков при разработке на JAVA

- **Spring Framework**: 
  - Инверсия управления (IoC), DI (Dependency Injection), Spring Boot для быстрой разработки.  
  - Модули Spring MVC, Spring Data, Spring Security.  
- **Hibernate**: реализация ORM (Object-Relational Mapping), преобразует классы Java в таблицы БД.  
- *Причины использования:* ускорение разработки, удобная архитектура, богатые экосистемы, гибкая конфигурация.

---

## 11. Объектная модель Java. Основные принципы объектной модели в Java: классы, объекты, интерфейсы, наследование и инкапсуляция. Класс Object и методы, которые он предоставляет

- **Класс** – это шаблон (blueprint).  
- **Объект** – экземпляр класса.  
- **Интерфейс** – контракт, набор методов без реализации (в классических версиях).  
- **Наследование** – расширение функционала родительского класса.  
- **Инкапсуляция** – сокрытие деталей реализации.  
- **Класс Object** – корневой в иерархии: методы toString(), equals(), hashCode(), clone(), finalize() и др.

---

## 12. Пакеты в Java. Основное предназначение. Структура, организация, использование в программировании (импорт пакетов)

- **Пакеты** (package) – логическая группировка классов, защита от конфликтов имён, организация кода.  
- *Структура:* директория → название пакета.  
- **import** – директива для использования классов из других пакетов.

---

## 13. Синтаксис и лексика Java. Основные элементы лексики языка: ключевые слова, идентификаторы, литералы, комментарии, операторы и разделители. Правила именования идентификаторов. Соглашения по оформлению кода

- **Ключевые слова**: class, public, static, if, else, for, try, catch и т.д.  
- **Идентификаторы**: названия классов, переменных, методов (не могут начинаться с цифры, не должны совпадать с ключевыми словами).  
- **Литералы**: числовые, символьные, строковые, логические (true, false).  
- **Комментарии**: //, /* */, /** */.  
- **Соглашения по оформлению**: Java Code Conventions (CamelCase, PascalCase для классов, и т.д.).

---

## 14. Типы данных в Java. Примитивные типы данных, объявление и присваивание переменных. Отличия примитивных типов данных от ссылочных

- **Примитивные типы**: byte, short, int, long, float, double, char, boolean.  
- Объявление: `int x = 10;`  
- Присваивание: `x = 20;`  
- *Отличие:* примитивы хранятся непосредственно в виде значения (в стеке), а ссылочные типы – хранятся в куче, а переменная содержит ссылку.

---

## 15. Типы данных в Java. Ссылочные типы данных, объявление и присваивание переменных. Отличия ссылочных типов данных от примитивных. Роль классов-оберток (Wrapper Classes) для работы с примитивами

- **Ссылочные типы**: классы, массивы, интерфейсы, перечисления, а также String.  
- Пример объявления: `String str = "Hello";`  
- При присваивании копируется ссылка, а не само значение.  
- **Wrapper-классы** (Integer, Double, Boolean и др.) позволяют использовать примитивы как объекты (например, при работе с коллекциями).

---

## 16. Константы в Java. Понятие констант и их объявление с использованием ключевого слова final. Основные правила и соглашения по именованию констант. Примеры создания констант для примитивных типов данных и строк. Как константы помогают обеспечить неизменность данных и улучшают читаемость кода?

- `final int MAX_SIZE = 100;`  
- Константы именуют обычно ЗАГЛАВНЫМИ_БУКВАМИ, слова разделяются подчеркиваниями.  
- Использование констант улучшает читаемость кода и предотвращает случайное изменение значения.

---

## 17. Ключевое слово var в Java. Особенности использования var для объявления локальных переменных. Как происходит неявное выведение типа переменной компилятором? Ограничения на использование var: недопустимость для полей класса, параметров методов и возвращаемых типов

- `var list = new ArrayList<String>(); // тип выводится из правой части`  
- *Особенности:* доступно с Java 10. Только локальные переменные внутри методов, конструкций for, try-with-resources.  
- Поля класса, параметры, возвращаемые типы – использовать var нельзя.

---

## 18. Соглашения по оформлению кода Java. Java Code Conventions и её значение для совместной работы

- Унификация стиля (отступы, скобки, имена).  
- Улучшает чтение кода и командную работу.  
- Использование инструментов: Checkstyle, SonarLint.

---

## 19. Класс и экземпляры класса. Что такое класс в Java и как происходит создание объектов (инстанцирование) с использованием ключевого слова new? Примеры создания и использования экземпляров класса

- **Класс** – определяет структуру и поведение (поля и методы).  
- **Создание**: `MyClass obj = new MyClass();`  
- Пример:

```java
public class Person {
    String name;
    int age;
    
    public void sayHello() {
        System.out.println("Hello, my name is " + name);
    }
}

// Использование
Person p = new Person();
p.name = "Alice";
p.age = 30;
p.sayHello();
```

---

## 20. Записи (Records) в Java. Какие возможности они предоставляют и в чем их отличие от обычных классов? Примеры использования записей

- **Records** (Java 16+): удобный способ объявить неизменяемый класс с полями и автогенерацией конструктора, equals, hashCode, toString.  
- Объявление:

```java
public record Point(int x, int y) {}
```

- В отличие от обычного класса, запись не может содержать изменяемые поля (они фактически final). Это короткая форма для «data-классов».

---

## 21. Запечатанные (Sealed) классы. Как они ограничивают наследование и для чего используются?

- **Sealed-классы** (Java 17+): позволяют ограничивать, кто может наследовать или реализовывать класс/интерфейс.  
- Объявление:

```java
public sealed class Shape permits Circle, Rectangle {
    // ...
}
```
- Для повышения безопасности и ясности иерархий.

---

## 22. Инкапсуляция в Java. Понятие инкапсуляции как механизма защиты данных и управления доступом к ним. Реализация инкапсуляции с использованием модификаторов доступа (private, protected, public, package-private). Роль геттеров и сеттеров в обеспечении контроля за изменением данных объекта. Примеры нарушения инкапсуляции и способы предотвращения этих ошибок

- **Инкапсуляция**: скрытие состояния объекта и управление доступом к нему.  
- Используются **модификаторы**: `private` (только внутри класса), `protected` (доступен подклассам и внутри пакета), `public` (доступен всем), *package-private* (не указан модификатор).  
- **Геттеры/сеттеры**: контролируют логику при чтении/записи.  
- Нарушение: публичные поля без контроля. Решение: поля private, доступ через методы.

---

## 23. Модификаторы доступа. Какие уровни доступа существуют в Java? Как модификаторы доступа используются для контроля видимости классов, полей и методов?

1. **public** – доступны всем.  
2. **protected** – доступно в текущем классе, подклассах, а также внутри пакета.  
3. *(package-private)* (умолчание) – доступ внутри пакета.  
4. **private** – доступен только внутри текущего класса.

---

## 24. Модификатор final. Применение final к переменным, методам и классам. Как он предотвращает изменения данных, поведение методов и наследование?

- **final переменная** – нельзя переназначить ссылку/значение.  
- **final метод** – нельзя переопределить метод в подклассе.  
- **final класс** – нельзя наследоваться от этого класса.

---

## 25. Конструкторы в Java. Понятие конструктора и его роль в создании объектов. Различия между конструктором и методом. Типы конструкторов. Как реализовать перегрузку конструкторов?

- **Конструктор** вызывается при создании объекта через `new`, имя совпадает с именем класса, без возвращаемого типа.  
- **Перегрузка** – несколько конструкторов с разными списками параметров:

```java
public class Person {
    public Person() {}
    public Person(String name) { ... }
    public Person(String name, int age) { ... }
}
```

---

## 26. Конструкторы в Java. Понятие конструктора и его роль в создании объектов. Использование ключевого слова this для вызова одного конструктора из другого. Особенности работы конструкторов в наследовании, вызов конструктора родительского класса через super

```java
public class Person {
    private String name;
    private int age;

    public Person() {
        this("Unknown"); // вызов конструктора с 1 параметром
    }

    public Person(String name) {
        this(name, 0); // вызов конструктора с 2 параметрами
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

- В наследовании при создании подкласса сначала вызывается конструктор родителя (через `super()`).

---

## 27. Блоки инициализации. Виды блоков инициализации: статические и нестатические. Их роль в подготовке объектов и классов. Примеры использования блоков для сокращения повторяющегося кода

- **Нестатический блок** (instance initializer) выполняется при создании каждого объекта.  
- **Статический блок** – при загрузке класса:

```java
public class Example {
    static {
        // статический блок
    }
    {
        // нестатический блок
    }
}
```

---

## 28. Статические блоки инициализации. Примеры и использование статических блоков для выполнения кода при загрузке класса. Их роль в инициализации общих данных

```java
public class Config {
    public static final Map<String, String> SETTINGS = new HashMap<>();
    static {
        SETTINGS.put("mode", "production");
        SETTINGS.put("version", "1.0");
    }
}
```

- Выполняются один раз при загрузке класса. Удобно для инициализации статических ресурсов.

---

## 29. Модификатор static. Особенности использования static для полей, методов и блоков. Различия между статическими и нестатическими членами класса. Примеры применения для создания общих ресурсов

- **static поле** – принадлежит классу, одно на все объекты.  
- **static метод** – вызывается без создания объекта (`Math.random()`), не имеет доступа к нестатическим полям.  
- **static блок** – инициализация статических полей.  

---

## 30. Ключевое слово this. Использование this для доступа к полям и методам объекта, вызова других конструкторов и передачи текущего объекта. Примеры решения конфликтов имен с помощью this

- Если локальная переменная совпадает с именем поля, `this.fieldName` разрешает конфликт.  
- Вызов конструктора: `this(...)`.  
- Передача текущего объекта в метод: `someMethod(this);`.

---

## 31. Концепция неизменяемых классов. Что делает класс неизменяемым? Использование final для предотвращения изменений. Примеры создания неизменяемых объектов

- **Неизменяемый класс**: все поля private и final, без сеттеров. Любое «изменение» возвращает новый объект.  
- Пример:

```java
public final class ImmutablePoint {
    private final int x;
    private final int y;

    public ImmutablePoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public int getX() { return x; }
    public int getY() { return y; }
}
```

---

## 32. Создание объектов. Отличие фабричных методов от стандартного создания объектов с использованием new. Примеры использования фабричных методов

- **new**: прямое создание объекта.  
- **Фабричные методы** (статические либо экземпляра) могут возвращать разные подклассы, кэшировать объекты, применять дополнительную логику.  
- Пример:

```java
public class ShapeFactory {
    public static Shape createCircle(double radius) {
        return new Circle(radius);
    }
}
```

---

## 33. Рефлексия в Java. Возможности рефлексии для создания объектов и вызова методов во время выполнения. Примеры использования рефлексии для создания объектов

```java
Class<?> clazz = Class.forName("com.example.Person");
Constructor<?> ctor = clazz.getConstructor();
Object obj = ctor.newInstance(); // Создание объекта через рефлексию
```

- Позволяет динамически получать информацию о классах, вызывать методы, доступ к полям.

---

## 34. Жизненный цикл объектов в JAVA. Роль сборщика мусора в управлении памятью. Примеры оптимизации работы объектов в Java

- **Жизненный цикл**: создание → использование → потеря ссылок → сборка мусора.  
- **GC** освобождает память автоматически.  
- Оптимизация: снижение числа временных объектов, использование пула объектов (например, пула строк).

---

## 35. Инициализация переменных в JAVA. Способы инициализации переменных: по умолчанию, в конструкторах, через блоки инициализации. Примеры применения

- **По умолчанию**: для примитивов нулевые значения (0, false, '\u0000'), для ссылок – null.  
- **Конструкторы**: универсальный способ задать значения при создании.  
- **Блоки инициализации** – сокращают дублирование кода в конструкторах.

---

## 36. Математические функции. Класс Math в Java и его методы для выполнения вычислений. Примеры использования тригонометрических и экспоненциальных функций в задачах. Нужно ли создавать объект класса Math для использования математических методов?

- **Класс Math** содержит статические методы: `Math.sqrt()`, `Math.sin()`, `Math.pow()`, `Math.random()` и т.д.  
- Объект создавать не нужно, методы вызываются напрямую: `Math.max(a, b)`.  

---

## 37. Абстракция и инкапсуляция класса. Понятие абстракции как отделения реализации класса от его использования. Как эти принципы улучшают структурирование кода и его модульность?

- **Абстракция**: вычленение существенных характеристик и сокрытие деталей реализации.  
- **Инкапсуляция**: см. вопрос 22.  
- Повышают гибкость, уменьшают связность (loose coupling).

---

## 38. Отношения между классами. Основные виды отношений между классами: ассоциация, агрегация, композиция, наследование

1. **Ассоциация** – «один объект использует другой».  
2. **Агрегация** – «has-a», но объекты живут независимо.  
3. **Композиция** – «part-of», объекты входят в состав и зависят от «владельца».  
4. **Наследование** – «is-a».

---

## 39. Ассоциация. Понятие ассоциации как бинарного отношения между классами. Примеры реализации ассоциации в Java. Как ассоциация помогает моделировать взаимодействие объектов?

- **Ассоциация**: классы Person и Car – Person может «использовать» Car.  
  ```java
  public class Person {
      private Car car;
      public void drive() {
          car.move();
      }
  }
  ```

---

## 40. Агрегация и композиция. Понятия агрегации и композиции, их различия. Как они отражают отношения «has-a» между объектами? Примеры реализации агрегации и композиции в проектировании классов

- **Агрегация**: объекты могут существовать независимо (например, Университет и Студент).  
- **Композиция**: «части» не могут существовать без целого (Комната в Доме).

```java
// Агрегация
public class University {
    private List<Student> students; // Существуют сами по себе
}

// Композиция
public class House {
    private List<Room> rooms = new ArrayList<>(); // Комнаты зависят от дома
}
```

---

## 41. Обработка примитивных типов как объектных. Использование классов-оберток для работы с примитивными типами как с объектами. Примеры преобразования примитивных типов в объекты и обратно

```java
int a = 10;
Integer aObj = Integer.valueOf(a); // автопаковка
int b = aObj.intValue();          // автораспаковка
```
- Классы-обёртки: Integer, Double, Float, etc.

---

## 42. Классы-обертки. Основные возможности классов-оберток: Integer, Double, Boolean и других. Методы для преобразования значений и сравнения объектов. Примеры использования методов parseInt, valueOf и compareTo

```java
int n = Integer.parseInt("123");
Integer x = Integer.valueOf("123");
int result = x.compareTo(100); // > 0 если x > 100
```
- Удобны для конвертации строк, хранения в коллекциях и пр.

---

## 43. Автоматическое преобразование. Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java? Как они автоматически преобразуют значения примитивных типов в объекты и обратно? Примеры использования

- **Autoboxing**: `Integer x = 5;` → автоматически `Integer.valueOf(5)`  
- **Unboxing**: `int y = x;` → `x.intValue()`  
- Упрощает синтаксис.

---

## 44. Класс String. Понятие неизменяемости (иммутабельности) строк в Java. Как создаются объекты типа String? Примеры работы с методами создания, сравнения и модификации строк

- **String** неизменяем: при любой операции «изменения» создаётся новый объект.  
- Создание: `String s1 = "Hello"; String s2 = new String("Hello");`  
- Сравнение: `s1.equals(s2)`, оператор `==` проверяет ссылки.  
- Методы: `substring()`, `replace()`, `toLowerCase()`, возвращают новый объект.

---

## 45. Строки в JAVA. Замена и разделение строк. Методы класса String для замены символов и разделения строк. Примеры работы с методами replace и split

```java
String text = "Java is cool.";
String replaced = text.replace("Java", "Python"); // "Python is cool."
String[] parts = text.split(" "); // {"Java", "is", "cool."}
```

---

## 46. Строки в JAVA. Преобразования между строками и массивами. Как преобразовать строку в массив символов и наоборот? Примеры использования методов toCharArray и valueOf

```java
String text = "Hello";
char[] chars = text.toCharArray();
String newText = String.valueOf(chars);
```

---

## 47. Строки в JAVA. Класс StringBuilder и StringBuffer. Понятие изменяемых строк. Основные отличия между StringBuilder и StringBuffer. Примеры их использования. Влияние классов StringBuilder и StringBuffer на типобезопасность

- **StringBuilder** и **StringBuffer** – изменяемые строки.  
- Отличие: `StringBuffer` потокобезопасен (synchronized), но медленнее; `StringBuilder` – более быстрый, но не потокобезопасный.  
- Пример:

```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World!");
System.out.println(sb.toString());
```

- *Типобезопасность* остаётся на уровне Java, разница лишь в потоковой безопасности.

---

## 48. Строки в JAVA. Преобразование символов и чисел в строки. Какие методы используются для преобразования чисел, символов и объектов в строки? Примеры работы с методами String.valueOf() и toString().

```java
int num = 100;
String strNum = String.valueOf(num); // "100"
char c = 'A';
String strChar = String.valueOf(c);  // "A"
Object obj = new Object();
String strObj = obj.toString();      // класс_и_хешкод
```

---

## 49. Строки в JAVA. Интернированные строки. Что такое интернированные строки? Как JVM оптимизирует работу с повторяющимися строками? Примеры их использования

- **Интернированные строки** хранятся в пуле (string pool). При создании литерала, JVM проверяет пул, не создавая новый объект, если такой уже есть.  
- Пример:  
  ```java
  String s1 = "Java";
  String s2 = "Java"; 
  // s1 == s2 -> true, так как оба указывают на один объект в пуле
  ```

---

## 50. Наследование в JAVA. Основные принципы наследования в Java. Что такое суперклассы (родительские) и подклассы (дочерние)? Как наследование помогает переиспользовать код? Примеры реализации наследования

- **Наследование**: `class Child extends Parent`.  
- Суперкласс – родитель, подкласс – ребёнок.  
- Позволяет переиспользовать поля и методы:

```java
class Animal {
    void eat() { System.out.println("Eating"); }
}

class Dog extends Animal {
    void bark() { System.out.println("Barking"); }
}
```

---

## 51. Перегрузка метода в Java (overload). Переопределение метода в Java (override). В чем разница между перегрузкой и переопределением методов?

- **Перегрузка (overload)**: методы с одинаковым именем, разными параметрами, внутри одного класса.  
- **Переопределение (override)**: метод в подклассе с такой же сигнатурой, как в суперклассе, изменяет реализацию.

---

## 52. Наследование и отношение is-a. Как наследование реализует отношение «is-a»? Когда использование наследования может быть нецелесообразным? Примеры решений

- **is-a**: Dog is an Animal.  
- Нецелесообразно, если объекты не имеют природного «is-a» отношения или если достаточно композиции. Например, «Car extends Engine» – сомнительно, лучше «Car has-an Engine».

---

## 53. Ключевое слово super. Роль ключевого слова super в Java. Использование для вызова методов и конструкторов суперкласса. Примеры реализации

```java
class Animal {
    void eat() { System.out.println("Animal eats"); }
}

class Dog extends Animal {
    void eat() {
        super.eat(); // вызов eat() родителя
        System.out.println("Dog eats too");
    }
}
```
- `super()` для вызова конструктора родителя.

---

## 54. Цепочка конструкторов. Понятие цепочки конструкторов. Как вызвать один конструктор из другого с использованием this() и super()? Примеры реализации

- Сначала вызывается конструктор родителя (`super()`), при необходимости можно вызывать перегруженные конструкторы внутри одного класса (`this(...)`).  
- См. вопрос 26 для примеров кода.

---

## 55. Класс Object и его основные методы. Роль класса Object как суперкласса для всех классов в Java. Как метод toString() используется для представления объекта в виде строки? Примеры переопределения метода

- **Object** – корень иерархии.  
- Методы: toString(), equals(), hashCode(), finalize(), clone() (с учетом интерфейса Cloneable).  
- Переопределение:

```java
@Override
public String toString() {
    return "Person{name=" + name + ", age=" + age + "}";
}
```

---

## 56. Полиморфизм. Понятие полиморфизма в Java. Как переменная супертипа может ссылаться на объект подтипа? Примеры применения полиморфизма для создания гибкого кода

- **Полиморфизм**: поведение зависит от реального типа объекта, даже если переменная объявлена как родительский тип:  
  ```java
  Animal a = new Dog(); 
  a.eat(); // вызывает метод Dog.eat()
  ```
- Удобно для работы с коллекциями разнородных объектов.

---

## 57. Интерфейсы в Java. Понятие интерфейсов как конструкций для определения общих операций. Основные элементы интерфейсов: константы и абстрактные методы. Примеры использования интерфейсов для создания обобщенных решений

```java
public interface Printable {
    void print();
}

public class Book implements Printable {
    public void print() {
        System.out.println("Printing book...");
    }
}
```

- Интерфейс – это контракт: какие методы должен реализовать класс.

---

## 58. Интерфейсы в Java. Понятие интерфейсов как конструкций для определения общих операций. Особенности интерфейсов, добавленные в JAVA 8 версии. Дефолтные методы в интерфейсах

- С Java 8 в интерфейсах можно объявлять методы со *стандартной реализацией* (default) и *статические методы*.  
- Пример:

```java
public interface MyInterface {
    default void defaultMethod() {
        System.out.println("Default implementation");
    }
    static void staticMethod() {
        System.out.println("Static method in interface");
    }
}
```

---

## 59. Интерфейсы в Java. Особенности интерфейсов. Чем интерфейсы отличаются от классов? Как используются ключевые слова interface и implements? Примеры объявления и реализации интерфейсов

- **Различия:** интерфейсы не хранят состояние, не имеют конструкторов, все методы по умолчанию абстрактные (кроме default, static, private).  
- `interface Printable { ... }`  
- `class Book implements Printable { ... }`

---

## 60. Интерфейсы в Java 8 и 9. Новые возможности интерфейсов, такие как default и static методы (Java 8), а также private и private static методы (Java 9). Примеры реализации и применения

- **Java 9** разрешила *private* и *private static* методы внутри интерфейса, чтобы изолировать вспомогательную логику:

```java
public interface MyInterface {
    private void helperMethod() {
        System.out.println("Private method");
    }
    default void doSomething() {
        helperMethod();
    }
}
```

---

## 61. Интерфейс Comparable. Как интерфейс Comparable используется для сравнения объектов? Реализация метода compareTo() и его роль в сортировке. Примеры работы с интерфейсом

```java
public class Person implements Comparable<Person> {
    private String name;
    @Override
    public int compareTo(Person other) {
        return this.name.compareTo(other.name);
    }
}
```
- `compareTo()` возвращает отрицательное/нулевое/положительное, определяя порядок.

---

## 62. Интерфейс Comparable для классов стандартной библиотеки JAVA. Как реализован интерфейс Comparable в классах String, Integer и Date? Примеры сравнения объектов с помощью метода compareTo()

- **String**: лексикографическое сравнение.  
- **Integer**: сравнение чисел.  
- **Date**: сравнение по времени (раньше/позже).  
- Пример: `int result = "abc".compareTo("abd");`

---

## 63. Интерфейс Comparable для пользовательских классов. Как реализовать интерфейс Comparable для пользовательских классов? Примеры сравнения объектов на основе пользовательских критериев

- См. вопрос 61.  
- Можно сравнивать по одному или нескольким полям. Например, сначала по фамилии, потом по имени.

---

## 64. Интерфейс Cloneable. Понятие клонирования объектов. Как интерфейс Cloneable позволяет клонировать объекты? Ограничения и примеры использования

- **Cloneable**: маркерный интерфейс; при его отсутствии `clone()` выбросит `CloneNotSupportedException`.  
- Реальное копирование делает метод `clone()` в Object. Нужно переопределять `clone()`.

---

## 65. Метод clone(). Как метод clone(), определенный в классе Object, используется совместно с интерфейсом Cloneable? Примеры работы с клонируемыми объектами

```java
public class Person implements Cloneable {
    public Person clone() throws CloneNotSupportedException {
        return (Person) super.clone();
    }
}
```
- Позволяет создавать поверхностные копии объекта.

---

## 66. Интерфейсы и абстрактные классы. Основные различия между интерфейсами и абстрактными классами

- **Интерфейс**: все методы абстрактные (до Java 8), нельзя хранить состояние (кроме static final полей).  
- **Абстрактный класс**: может содержать состояние, реализованные методы, конструкторы; но нельзя инстанцировать напрямую.

---

## 67. Понятие абстрактных классов в Java. Что такое абстрактный класс, и как он используется для создания общего базового поведения? Чем отличается абстрактный класс от интерфейса? Примеры объявления и реализации абстрактного класса с абстрактными и конкретными методами

```java
public abstract class Animal {
    public abstract void makeSound();
    public void eat() {
        System.out.println("Eating");
    }
}
```
- Класс **abstract** нельзя создать напрямую: `new Animal()` запрещено.

---

## 68. Понятие абстрактных классов в Java. Объявление абстрактных методов. Что такое абстрактный метод, и какие правила нужно соблюдать при его объявлении? Как абстрактные методы помогают подклассам реализовать специфическое поведение? Примеры реализации абстрактных методов в наследуемых классах

- **Абстрактный метод** не имеет тела, заканчивается `;`.  
- Подклассы обязаны его реализовать:

```java
public abstract class Shape {
    public abstract double area();
}

public class Circle extends Shape {
    public double area() {
        return Math.PI * radius * radius;
    }
}
```

---

## 69. Понятие абстрактных классов в Java. Особенности работы с абстрактными классами. Почему абстрактные классы нельзя инстанцировать? Как использовать абстрактный класс как основу для других классов? Примеры создания иерархии классов с базовым абстрактным классом

- **Нельзя инстанцировать**: т.к. абстрактный метод без реализации.  
- Абстрактные классы – «каркас»; конкретные подклассы дополняют детали.

---

## 70. Ограничение множественного наследования в JAVA. Множественное наследование интерфейсов. Как классы наследуют методы от нескольких интерфейсов?

- **Множественное наследование классов** недоступно. Можно `implements` несколько интерфейсов:  
  ```java
  class MyClass implements InterfaceA, InterfaceB { ... }
  ```
- При конфликте default-методов нужно переопределять.

---

## 71. Интерфейсы в Java. Особенности интерфейсов. Интерфейсы и полиморфизм. Как интерфейсы способствуют реализации полиморфизма?

- Интерфейсы позволяют работать с разными реализациями через общий тип.  
- `List<String> list = new ArrayList<>();` или `list = new LinkedList<>();` – полиморфизм в действии.

---

## 72. Обработка исключительных ситуаций в JAVA. Основные способы и подходы к обработке исключительных ситуаций в JAVA. Иерархия классов исключений в Java. Понятие и структура иерархии исключений. Чем отличаются классы Error, Exception и RuntimeException?

- **Error**: сбои в работе JVM (OutOfMemoryError). Не обрабатываются обычно.  
- **Exception**: делятся на *checked* и *unchecked*.  
- **RuntimeException**: непроверяемые исключения (NullPointerException, IndexOutOfBoundsException).

---

## 73. Создание и генерация исключений. Как создавать и генерировать исключения с помощью ключевого слова throw? Различия между throw и throws. Примеры создания пользовательских исключений

- `throw` – фактическая генерация исключения:

```java
if (value < 0) {
    throw new IllegalArgumentException("Value cannot be negative!");
}
```

- `throws` – объявление, что метод может выбросить исключение:

```java
public void myMethod() throws IOException {
    // ...
}
```

- Пользовательское исключение: `class MyException extends Exception { ... }`

---

## 74. Обработка исключений. Структура блока try-catch. Как обрабатывать исключения с использованием блоков try-catch? Примеры обработки нескольких исключений и упорядочения блоков catch. Роль объекта исключения (Exception e) в блоке catch

```java
try {
    // код, в котором может быть исключение
} catch (IOException e) {
    // обработка IOException
} catch (Exception e) {
    // обработка любого другого исключения
}
```
- Блоки catch упорядочены от более частных к более общим.

---

## 75. Обработка исключений. Структура блока try-catch. Блок finally и его использование. Основные причины использования. Примеры использования

```java
FileInputStream fis = null;
try {
    fis = new FileInputStream("file.txt");
    // чтение файла
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fis != null) {
        try { fis.close(); } catch (IOException e) { e.printStackTrace(); }
    }
}
```
- `finally` выполняется независимо от того, было исключение или нет, обычно для освобождения ресурсов.

---

## 76. Обработка исключений. Пропагирование исключений. Как исключения передаются вверх по стеку вызовов? Примеры использования ключевого слова throws в сигнатуре методов

- Исключения «прокидываются» вверх, пока не будут обработаны или пока не достигнут главного метода.  
- `public void readFile() throws IOException { ... }`

---

## 77. Обработка исключений. Проверяемые и непроверяемые исключения. Какие исключения считаются проверяемыми (checked), а какие – непроверяемыми (unchecked)? Примеры работы с ними. Исключения в популярных фреймворках. Почему большинство исключений в современных фреймворках являются непроверяемыми?

- **Checked**: Exception (кроме RuntimeException). Компилятор требует обработку.  
- **Unchecked**: RuntimeException и его подклассы.  
- В фреймворках предпочтительнее непроверяемые (меньше «шумного» кода, гибче обработка).

---

## 78. Обработка исключений. Использование try-with-resources. Как она упрощает управление ресурсами? Примеры работы

```java
try (FileInputStream fis = new FileInputStream("file.txt");
     BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {
    // Используем ресурс
} catch (IOException e) {
    e.printStackTrace();
}
```
- Ресурсы автоматически закрываются.

---

## 79. Обработка исключительных ситуаций в JAVA. Роль JVM в обработке исключений. Как JVM управляет исключениями, если они не были обработаны? Примеры поведения при неперехваченных исключениях

- Если исключение не перехвачено, JVM завершит программу и выведет stack trace в консоль.  
- Пример: `Exception in thread "main" ...`

---

## 80. Перечисления (enums) в Java. Что такое перечисления и как они используются для создания фиксированных наборов значений? Характеристики перечислений. Перечисления и типобезопасность. Примеры их применения

- **enum** – набор именованных констант:

```java
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, ...
}
```
- Типобезопасны, по сравнению с «магическими» числами или строками.

---

## 81. GUI в Java. Что такое GUI (графический пользовательский интерфейс)? Основные пакеты для работы с GUI в Java: AWT и Swing

- **GUI**: графический интерфейс (окна, кнопки, формы).  
- **AWT** (Abstract Window Toolkit) – «старый» фреймворк, тяжеловесные компоненты.  
- **Swing** – поверх AWT, «легковесные» компоненты, расширенные возможности.

---

## 82. GUI в Java. Структура GUI в JAVA при реализации через Swing и AWT. Компоненты GUI. Какие элементы составляют графический интерфейс? Примеры кнопок, текстовых полей и других компонентов

- Основные **компоненты**: окна (Frame, JFrame), контейнеры (Panel, JPanel), кнопки (Button, JButton), метки (Label, JLabel), текстовые поля (TextField, JTextField).  
- Swing добавляет «J» к названиям AWT-компонентов.

---

## 83. AWT (Abstract Window Toolkit). Что такое AWT и как он используется для создания GUI? Примеры простых интерфейсов с использованием AWT

```java
Frame frame = new Frame("AWT Example");
Button btn = new Button("Click me");
frame.add(btn);
frame.setSize(300, 200);
frame.setVisible(true);
```

---

## 84. Swing в Java. Как Swing расширяет возможности AWT? Примеры создания интерфейсов с использованием Swing. Паттерн MVC в Swing. Как Swing реализует модель MVC (Model-View-Controller)? Примеры разделения логики, представления и управления в интерфейсе

- **Swing** – обширный набор компонентов (`JFrame`, `JPanel`, `JButton` и т.д.), настраиваемый внешний вид (pluggable look and feel).  
- **MVC**: модель (данные), представление (компоненты Swing), контроллер (слушатели событий).

Пример:

```java
JFrame frame = new JFrame("Swing Example");
JButton btn = new JButton("Click me");
frame.add(btn);
frame.setSize(300, 200);
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
frame.setVisible(true);
```

---

## 85. Структура GUI в Java. Основные компоненты GUI в Swing: контейнеры (JFrame, JPanel, JDialog), компоненты (JButton, JLabel, JTextField) и менеджеры компоновки

- **JFrame** – главное окно.  
- **JPanel** – панель для размещения компонентов.  
- **JDialog** – диалоговое окно.  
- **JButton, JLabel, JTextField** – стандартные элементы.  
- **Менеджеры компоновки**: FlowLayout, BorderLayout, GridLayout и др.

---

## 86. Класс JFrame. Что такое окно JFrame, и как использовать его для создания графического интерфейса? Примеры добавления элементов через метод getContentPane()

```java
JFrame frame = new JFrame("My App");
Container contentPane = frame.getContentPane();
contentPane.add(new JButton("Button"));
frame.setSize(400, 300);
frame.setVisible(true);
```

---

## 87. Класс JPanel. Как панель JPanel используется для группировки и управления компонентами? Примеры изменения менеджера компоновки с помощью метода setLayout()

```java
JPanel panel = new JPanel();
panel.setLayout(new BorderLayout());
panel.add(new JButton("Center"), BorderLayout.CENTER);
```
- Группировка логически связанных элементов.

---

## 88. Менеджеры компоновки в Java. Роль менеджеров компоновки в управлении размещением компонентов. Примеры использования менеджеров FlowLayout, BorderLayout, GridLayout

- **FlowLayout**: располагает компоненты слева направо, перенося на новую строку.  
- **BorderLayout**: делит контейнер на регионы (NORTH, SOUTH, EAST, WEST, CENTER).  
- **GridLayout**: сетка с заданным количеством строк/столбцов.

---

## 89. Менеджер FlowLayout. Как работает FlowLayout? Примеры настройки выравнивания и промежутков между компонентами

```java
FlowLayout flow = new FlowLayout(FlowLayout.LEFT, 10, 20);
panel.setLayout(flow);
```
- Раскладывает компоненты «потоком».

---

## 90. Менеджеры компоновки в Java. Роль менеджеров компоновки в управлении размещением компонентов. Примеры использования менеджеров FlowLayout, BorderLayout, GridLayout

(Дублирует 88) – см. выше.

---

## 91. Менеджер FlowLayout. Как работает FlowLayout? Примеры настройки выравнивания и промежутков между компонентами

(Дублирует 89) – см. выше.

---

## 92. Менеджер BorderLayout. Как BorderLayout делит контейнер на регионы (NORTH, SOUTH, EAST, WEST, CENTER)? Примеры создания интерфейсов с четкой организацией областей

```java
panel.setLayout(new BorderLayout());
panel.add(new JButton("North"), BorderLayout.NORTH);
panel.add(new JButton("Center"), BorderLayout.CENTER);
```

---

## 93. Менеджер GridLayout. Как компоненты размещаются в сетке с использованием GridLayout? Примеры создания таблиц или форм

```java
panel.setLayout(new GridLayout(2, 3)); // 2 строки, 3 столбца
```

---

## 94. Менеджер BoxLayout. Как компоненты размещаются по горизонтали или вертикали с помощью BoxLayout? Примеры последовательного расположения элементов

```java
panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS)); // вертикально
panel.add(new JButton("Button 1"));
panel.add(new JButton("Button 2"));
```

---

## 95. Границы в Swing. Как использовать границы для улучшения внешнего вида интерфейса? Примеры применения границ

```java
panel.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));
```
- Также есть EmptyBorder, TitledBorder и др.

---

## 96. GUI и событийная модель в Java. Что такое событийная модель, и как она используется для взаимодействия компонентов через события? Основные элементы событийной модели

- **Событийная модель**: объект-источник генерирует событие, «слушатель» (listener) реагирует.  
- *Основные элементы:* источник события, объект события (EventObject), слушатель (Listener).

---

## 97. Обработка событий в Java. Как источник события, слушатель и обработчик взаимодействуют в событийной модели? Примеры добавления слушателей событий. Модель делегирования событий. Как работает модель делегирования событий?

- Источник (Button) при нажатии создаёт Event, передаёт слушателю (ActionListener).  
- *Модель делегирования*: компонент не обрабатывает событие сам, а делегирует слушателю.

```java
button.addActionListener(e -> System.out.println("Clicked!"));
```

---

## 98. Обработка событий при реализации GUI в JAVA. Классы событий пакета java.awt.event. Какие классы событий предоставляет пакет java.awt.event? Примеры обработки событий мыши и клавиатуры

- **События**: `ActionEvent`, `MouseEvent`, `KeyEvent`, `WindowEvent` и др.  
- Пример:

```java
button.addMouseListener(new MouseAdapter() {
    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println("Mouse clicked at " + e.getX() + "," + e.getY());
    }
});
```

---

## 99. Обработка событий мыши в JAVA. Как использовать интерфейсы MouseListener и MouseMotionListener для обработки событий мыши? Примеры обработки нажатий и перемещений

```java
panel.addMouseListener(new MouseListener() {
    public void mousePressed(MouseEvent e) { }
    // остальные методы
});
panel.addMouseMotionListener(new MouseMotionListener() {
    public void mouseMoved(MouseEvent e) { }
    // ...
});
```

---

## 100. Обработка событий клавиатуры в JAVA. Как обрабатывать события клавиатуры с использованием KeyListener? Примеры регистрации слушателей клавиатурных событий

```java
frame.addKeyListener(new KeyAdapter() {
    @Override
    public void keyPressed(KeyEvent e) {
        if(e.getKeyCode() == KeyEvent.VK_ENTER) {
            System.out.println("Enter pressed");
        }
    }
});
```

---

## 101. Обобщённое программирование в Java. Понятие обобщённого программирования и его роль в упрощении создания алгоритмов для работы с различными типами данных. История развития в JAVA. Примеры проектирования универсальных структур данных и алгоритмов

- **Generics**: добавлены в Java 5 для обеспечения *типобезопасности*.  
- Позволяют писать универсальные классы, методы, интерфейсы, которые работают с «T», «E» и т.п.

---

## 102. Generics в Java. Реализация обобщенного программирования через Generics. Основные синтаксические конструкции: параметры типов, обобщенные классы и методы. Примеры работы с параметризованными классами и методами. Преимущества и недостатки Generics

```java
public class Box<T> {
    private T content;
    public Box(T content) { this.content = content; }
    public T getContent() { return content; }
}
```
- *Преимущества:* типобезопасность, читаемость.  
- *Недостатки:* «стирание типов» и сложности при работе с примитивами.

---

## 103. Коллекции и Generics в Java. Как использование Generics повысило типобезопасность коллекций, таких как ArrayList, HashMap и HashSet? Примеры создания и обработки коллекций с обобщениями

```java
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123);  // Ошибка компиляции
```
- Без Generics (до Java 5) подобные ошибки проверялись лишь во время выполнения.

---

## 104. Параметризованные методы. Понятие параметризованных методов в Java. Как они позволяют работать с любыми типами данных? Примеры реализации методов с обобщенными параметрами и их вызова

```java
public static <T> void printArray(T[] arr) {
    for(T item : arr) {
        System.out.println(item);
    }
}
```
- Вызывается: `printArray(new String[]{"A", "B"});`

---

## 105. Generics в Java. Типовые ограничения в Generics. Как задать ограничения на параметры типов с помощью ключевых слов extends и super? Примеры их использования для обеспечения гибкости и безопасности обобщений

- `<? extends Number>` – можно читать как Number, но нельзя безопасно записывать.  
- `<? super Integer>` – можно записывать Integer, но нельзя безопасно читать (только Object).

---

## 106. Обобщенные интерфейсы. Использование Generics для создания универсальных интерфейсов. Примеры реализации обобщенных интерфейсов и их применения в реальных задачах

```java
public interface Storage<T> {
    void add(T item);
    T get();
}
```
- Реализация: `public class BoxStorage implements Storage<String> { ... }`

---

## 107. Generics в Java. Подстановочные знаки (Wildcards). Как использовать `?`, `<? extends T>` и `<? super T>` для работы с коллекциями? Примеры их применения

- `List<?>` – список неизвестного типа.  
- `List<? extends Number>` – список числовых типов, можно читать как Number.  
- `List<? super Integer>` – список типа Integer или его суперклассов, можно добавлять Integer.

---

## 108. Generics в Java. Стирание типов (Type Erasure). Как информация о Generics удаляется во время компиляции? Примеры преобразования Generics в сырой тип

- **Type Erasure**: во время выполнения JVM видит «сырые» типы.  
- `List<String>` и `List<Integer>` после компиляции становятся `List`.  
- Это сделано для обратной совместимости со старым кодом.

---

## 109. Коллекции в Java. Понятие коллекций как структур данных для хранения объектов. Основные интерфейсы и классы в Java Collections Framework (JCF). Примеры использования коллекций для хранения и обработки данных

- **Основные интерфейсы**: `Collection`, `List`, `Set`, `Map`.  
- **Ключевые реализации**: `ArrayList`, `LinkedList`, `HashSet`, `TreeSet`, `HashMap`, `TreeMap`, `LinkedHashMap`.  

---

## 110. Иерархия коллекций. Структура иерархии коллекций в Java. Основные интерфейсы (Collection, List, Set, Map) и их ключевые особенности. Примеры реализации различных типов коллекций

- **Collection** – корневой интерфейс для List/Set/Queue.  
- **List** – упорядоченная, индексированная. Реализации: `ArrayList`, `LinkedList`.  
- **Set** – уникальные элементы. Реализации: `HashSet`, `TreeSet`.  
- **Map** – ключ-значение. Реализации: `HashMap`, `TreeMap`.

---

## 111. LinkedList в Java. Особенности класса LinkedList как реализации интерфейса List. Преимущества использования

- **LinkedList**: двусвязный список. Быстрые вставки/удаления на концах, но медленный доступ по индексу.  

---

## 112. Коллекции в Java. Понятие коллекций как структур данных для хранения объектов. Основные цели использования коллекций. Роль Iterable в Java Collections Framework

- **Коллекции**: гибкое хранение произвольного количества элементов, алгоритмы для поиска, сортировки и т.д.  
- **Iterable**: базовый интерфейс, позволяющий использовать цикл `for-each`.

---

## 113. Коллекции в Java. Реализации List - ArrayList. Особенности функционирования ArrayList. Пример использования ArrayList

- **ArrayList** хранит элементы в динамическом массиве. Быстрый доступ по индексу, но вставка в середину может быть дорогой.  
- Пример:

```java
List<String> list = new ArrayList<>();
list.add("One");
list.add("Two");
System.out.println(list.get(0));
```

---

## 114. Коллекции в Java. Создание Generic Collection в Java. Преимущества данного подхода. Примеры

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
```
- *Преимущества:* нет ошибок «ClassCastException» при извлечении, повышенная читаемость.

---

## 115. Коллекции и Generics. Использование Generics для типобезопасности в коллекциях. Примеры создания типизированных списков и множеств

```java
Set<String> set = new HashSet<>();
set.add("Hello");
```
- Исключает добавление объектов неверного типа.

---

## 116. ArrayList в Java. Понятие ArrayList как реализации интерфейса List. Основные методы (add, get, remove) для работы со списками. Примеры добавления, удаления и доступа к элементам

```java
ArrayList<String> list = new ArrayList<>();
list.add("A");
list.add("B");
System.out.println(list.get(0)); // "A"
list.remove("A");
System.out.println(list); // ["B"]
```

---

## 117. Задача на выполнение

Вместо конкретной задачи здесь приведён полный перечень вопросов. Предположим, что экзаменационная задача может потребовать написать программу, где нужно продемонстрировать основные возможности языка (ООП, коллекции, исключения). Пример упрощённой экзаменационной мини-задачи:

**Задание**:  
1. Создать класс `Student` с полями `name`, `age`.  
2. Реализовать интерфейс `Comparable<Student>` для сортировки по `name`.  
3. Создать список студентов (ArrayList), добавить несколько объектов `Student`.  
4. Отсортировать список, вывести отсортированные результаты.  
5. Продемонстрировать обработку исключений при неправильном возрасте (например, если возраст отрицательный).

**Пример реализации**:

```java
public class Student implements Comparable<Student> {
    private String name;
    private int age;

    public Student(String name, int age) throws IllegalArgumentException {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Student other) {
        return this.name.compareTo(other.name);
    }

    @Override
    public String toString() {
        return "Student{name='" + name + "', age=" + age + "}";
    }
}

// Использование в main:
import java.util.*;

public class ExamTask {
    public static void main(String[] args) {
        try {
            List<Student> students = new ArrayList<>();
            students.add(new Student("Bob", 20));
            students.add(new Student("Alice", 22));
            students.add(new Student("Charlie", 18));

            Collections.sort(students);

            for(Student s : students) {
                System.out.println(s);
            }

            // Проверка исключения
            Student s2 = new Student("David", -5);

        } catch (IllegalArgumentException e) {
            System.err.println("Exception: " + e.getMessage());
        }
    }
}
```

Таким образом, в рамках одной задачи можно продемонстрировать:
- Создание класса и его экземпляров.  
- Реализацию интерфейса Comparable и сортировку коллекции.  
- Обработку исключений.  

---

**Удачи на экзамене и в дальнейшем изучении Java!**
